pragma ever-solidity ^0.66.0;

pragma AbiHeader time;
pragma AbiHeader expire;
pragma AbiHeader pubkey;

import "../utils/Constants.tsol";
import "../utils/ErrorCodes.tsol";
import "../utils/Gas.tsol";
import "../utils/TransferUtils.tsol";
import "../vault/MultiVault.tsol";
import "./abstract/Server.tsol";
import "./Message.tsol";


contract Profile is IProfile, MultiVault, PlatformUtils, TransferUtils {
    using PaymentLibrary for Payment;

    event CreateRoom(uint64 serverID);
    event MessageSent(uint messageHash, uint64 serverID, uint64 roomID, bool highlight);
    event Reacted(uint64 serverID, uint64 roomID, uint64 messageID, uint32 reaction, bool undo);
    event Deposited(address token, uint128 amount);
    event PermissionChanged(address entity, bool removed);
    event MessageAccepted(uint messageHash, uint64 serverID, uint64 roomID, uint64 messageID, bool deployed);

    address _owner;

    mapping(uint => bool) _pubkeys;
    mapping(address => UserData) _userDatas;
    mapping(address => Permissions) _permissions;
    // serverID => roomID => messageID => reaction => bool
    mapping(uint64 => mapping(uint64 => mapping(uint64 => mapping(uint32 => bool)))) _reactions;
    uint _currentMessageHash;
    uint64 _timestamp;


    modifier onlyOwner() {
        require(msg.sender == _owner, ErrorCodes.IS_NOT_OWNER);
        _;
    }


    function onCodeUpgrade(address root, TvmCell platformCode, TvmCell initialData, TvmCell initialParams) internal {
        tvm.resetStorage();
        _initPlatform(root, platformCode);
        _owner = abi.decode(initialData, address);
        uint[] pubkeys = abi.decode(initialParams, uint[]);
        _setPubkeys(pubkeys);
    }

    function afterSignatureCheck(TvmSlice body, TvmCell message) private inline returns (TvmSlice) {
        uint64 maxTimestamp = uint64(now + 30) * 1000;
        uint64 msgTimestamp = body.decode(uint64);
        require(msgTimestamp > _timestamp && msgTimestamp <= maxTimestamp, ErrorCodes.EXTERNAL_MSG_REPLAY_PROTECTION);
        _timestamp = msgTimestamp;

        uint32 expireAt = body.decode(uint32);
        require(expireAt >= now, ErrorCodes.EXTERNAL_MSG_IS_EXPIRED);

        uint pubkey = msg.pubkey();
        require(_pubkeys.exists(pubkey) && pubkey != 0, 69);

        uint messageHash = tvm.hash(message);
        require(messageHash != _currentMessageHash, 69);
        _currentMessageHash = messageHash;
        return body;
    }


    function createRoom(uint64 serverID, TvmCell params, Payment payment) public onlyOwner {
        uint128 minValue = Gas.CREATE_ROOM_VALUE + payment.evers();
        require(msg.value >= minValue, 69);

        emit CreateRoom(serverID);
        address server = _serverAddress(serverID);
        CallData data = _buildCallData(server, payment);
        if (payment.isEver()) {
            _createRoomPayEver(server, data, params);
        } else {
            TvmCell payload = abi.encode(data, params);
            _executePayTIP3(payment, server, payload, Gas.CREATE_ROOM_VALUE);
        }
    }

    function sendMessage(
        uint8 version,
        uint64 serverID,
        uint64 roomID,
        string message,
        optional(uint) replyToMessageHash,
        optional(uint) forwardMessageHash,
        bool highlight,
        Payment payment
// todo
//        address[] tagged,
//        uint128[] taggedValue
    ) public externalMsg {
        require(version == Constants.MESSAGE_VERSION, 69);
        tvm.accept();
        if (forwardMessageHash.hasValue()) {
            // forward message doesn't have `message` and `replyToMessageHash`
            uint32 length = message.byteLength();
            require(length == 0 && !replyToMessageHash.hasValue(), 69);
        }

        emit MessageSent(_currentMessageHash, serverID, roomID, highlight);
        address room = _roomAddress(serverID, roomID);
        CallData data = _buildCallData(room, payment);
        if (payment.isEver()) {
            _sendMessagePayEver(room, data, highlight);
        } else {
            TvmCell payload = abi.encode(data, _currentMessageHash, highlight);
            _executePayTIP3(payment, room, payload, Gas.SEND_MESSAGE_VALUE);
        }
    }

    function react(
        uint64 serverID,
        uint64 roomID,
        uint64 messageID,
        uint32 reaction,
        bool undo
    ) public minValue(Gas.REACT_VALUE) onlyOwner {
        _reserve();
        bool hasReaction = _reactions[serverID][roomID][messageID][reaction];
        require(hasReaction == undo, 69);

        emit Reacted(serverID, roomID, messageID, reaction, undo);
        address message = _messageAddress(serverID, roomID, messageID);
        Message(message).react{
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED,
            bounce: true
        }(_owner, reaction, undo);
        if (undo) {
            delete _reactions[serverID][roomID][messageID][reaction];
        } else {
            _reactions[serverID][roomID][messageID][reaction] = true;
        }
    }

    function deposit() public pure minValue(Gas.MIN_DEPOSIT_VALUE) {
        emit Deposited(address(0), msg.value);
    }

    function setPubkeys(uint[] pubkeys) public cashBack onlyOwner {
        delete _pubkeys;
        _setPubkeys(pubkeys);
    }

    function setServerPermissions(
        uint64 serverID,
        optional(Permissions) permissions,
        address remainingGasTo
    ) public override onlyServer(serverID) {
        _reserve();
        address server = _serverAddress(serverID);
        _setPermissions(server, permissions, remainingGasTo);
    }

    function setRoomPermissions(
        uint64 serverID,
        uint64 roomID,
        optional(Permissions) permissions,
        address remainingGasTo
    ) public override onlyRoom(serverID, roomID) {
        _reserve();
        address room = _roomAddress(serverID, roomID);
        _setPermissions(room, permissions, remainingGasTo);
    }

    function onMessageAccepted(
        uint64 serverID,
        uint64 roomID,
        uint64 messageID,
        uint messageHash,
        bool deployed
    ) public override {
        address sender = deployed ? _messageAddress(serverID, roomID, messageID) : _roomAddress(serverID, roomID);
        require(msg.sender == sender, 69);
        emit MessageAccepted(messageHash, serverID, roomID, messageID, deployed);
    }


    function _buildCallData(address recipient, Payment payment) private view returns (CallData) {
        optional(UserData) userData = _userDatas.fetch(recipient);
        optional(Permissions) permissions = _permissions.fetch(recipient);
        return CallData(_owner, payment, userData, permissions);
    }

    function _createRoomPayEver(address server, CallData data, TvmCell params) private pure {
        Server(server).createRoom{
            value: Gas.CREATE_ROOM_VALUE + data.payment.amount,
            flag: MsgFlag.SENDER_PAYS_FEES,
            bounce: true
        }(data, params);
    }

    function _sendMessagePayEver(address room, CallData data, bool highlight) private view {
        Room(room).acceptMessage{
            value: Gas.SEND_MESSAGE_VALUE + data.payment.amount,
            flag: MsgFlag.SENDER_PAYS_FEES,
            bounce: true
        }(data, _currentMessageHash, highlight);
    }

    function _executePayTIP3(Payment payment, address recipient, TvmCell payload, uint128 value) private {
        bool success = _transferTokens(payment.token, payment.amount, recipient, payload, value, MsgFlag.SENDER_PAYS_FEES);
        require(success, 69);
    }

    function _setPubkeys(uint[] pubkeys) private {
        for (uint pubkey : pubkeys) {
            _pubkeys[pubkey] = true;
        }
    }

    function _setPermissions(address entity, optional(Permissions) permissions, address remainingGasTo) private {
        bool removed = !permissions.hasValue();
        emit PermissionChanged(entity, removed);
        if (removed) {
            delete _permissions[entity];
        } else {
            _permissions[entity] = permissions.get();
        }
        IUser(remainingGasTo).onPermissionChanged{value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false}(entity, removed);
    }

    function _onAcceptTokensTransfer(address token, uint128 amount, address sender, TvmCell /*payload*/) internal override {
        _reserve();
        emit Deposited(token, amount);
        IUser(sender).onTokenDeposited{value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false}(token, amount);
    }

}
