pragma ever-solidity ^0.66.0;

import "../../utils/Constants.tsol";
import "../../utils/ErrorCodes.tsol";
import "../../vault/MultiVault.tsol";
import "./Server.tsol";


abstract contract Profile is IProfile, MultiVault, PlatformUtils, TransferUtils {
    using PaymentLibrary for Payment;

    event CreateRoom(uint64 serverID);
    event SendMessage(uint messageHash, uint64 serverID, uint64 roomID, bool highlight);

    event Deposited(address token, uint128 amount);
    event PermissionChanged(address entity, bool removed);
    event Tagged(uint64 serverID, uint64 roomID, uint64 messageID, address user);
    event MessageAccepted(uint messageHash, uint64 serverID, uint64 roomID, uint64 messageID, bool deployed);


    address _owner;

    uint128 _sendMessageValue;
    uint128 _minTagValue;
    mapping(uint => bool) _pubkeys;
    mapping(address => TvmCell) _userDatas;
    mapping(address => Permissions) _permissions;
    uint _currentMessageHash;
    uint64 _timestamp;


    modifier onlyOwner() {
        require(msg.sender == _owner, ErrorCodes.IS_NOT_OWNER);
        _;
    }


    function onCodeUpgrade(address root, TvmCell platformCode, TvmCell initialData, TvmCell initialParams) internal {
        tvm.resetStorage();
        _initPlatform(root, platformCode);
        _owner = abi.decode(initialData, address);
        uint[] pubkeys;
        (_sendMessageValue, _minTagValue, pubkeys) = abi.decode(initialParams, (uint128, uint128, uint[]));
        _setPubkeys(pubkeys);
    }

    function afterSignatureCheck(TvmSlice body, TvmCell message) private inline returns (TvmSlice) {
        uint64 maxTimestamp = uint64(now + 30) * 1000;
        uint64 msgTimestamp = body.decode(uint64);
        require(msgTimestamp > _timestamp && msgTimestamp <= maxTimestamp, ErrorCodes.EXTERNAL_MESSAGE_REPLAY);
        _timestamp = msgTimestamp;

        uint32 expireAt = body.decode(uint32);
        require(expireAt >= now, ErrorCodes.EXTERNAL_MESSAGE_EXPIRED);

        uint pubkey = msg.pubkey();
        require(_pubkeys.exists(pubkey) && pubkey != 0, ErrorCodes.WRONG_PUBLIC_KEY);

        uint messageHash = tvm.hash(message);
        require(messageHash != _currentMessageHash, ErrorCodes.MESSAGE_ALREADY_PROCESSED);
        _currentMessageHash = messageHash;
        return body;
    }


    function sendMessage(
        uint8 version,
        uint64 serverID,
        uint64 roomID,
        bytes message,
        Tag[] tags,
        optional(uint) replyToMessageHash,
        optional(uint) forwardMessageHash,
        bool highlight,
        Payment payment
    ) public externalMsg {
        require(version == Constants.MESSAGE_VERSION, ErrorCodes.WRONG_MESSAGE_VERSION);
        tvm.accept();
        if (forwardMessageHash.hasValue()) {
            // forward message doesn't have `message` and `replyToMessageHash`
            require(message.length == 0 && !replyToMessageHash.hasValue(), ErrorCodes.FORWARDED_MESSAGE_WITH_CONTENT);
        }

        emit SendMessage(_currentMessageHash, serverID, roomID, highlight);
        address room = _roomAddress(serverID, roomID);
        CallData data = _buildCallData(room, payment);
        uint128 value = _sendMessageValue + payment.evers() + _sumTagsValue(tags);
        if (payment.isEver()) {
            _sendMessagePayEver(room, data, tags, highlight, value);
        } else {
            TvmCell payload = abi.encode(data, _currentMessageHash, tags, highlight);
            _executePayTIP3(payment, room, payload, value);
        }
    }

    function deposit() public pure minValue(Gas.MIN_DEPOSIT_VALUE) {
        emit Deposited(address(0), msg.value);
    }

    function setMinTagValue(uint128 minTagValue) public cashBack onlyOwner {
        _minTagValue = minTagValue;
    }

    function setPubkeys(uint[] pubkeys) public cashBack onlyOwner {
        delete _pubkeys;
        _setPubkeys(pubkeys);
    }


    function setServerPermissions(
        uint64 serverID,
        optional(Permissions) permissions,
        address remainingGasTo
    ) public override onlyServer(serverID) {
        _reserve();
        address server = _serverAddress(serverID);
        _setPermissions(server, permissions, remainingGasTo);
    }

    function setRoomPermissions(
        uint64 serverID,
        uint64 roomID,
        optional(Permissions) permissions,
        address remainingGasTo
    ) public override onlyRoom(serverID, roomID) {
        _reserve();
        address room = _roomAddress(serverID, roomID);
        _setPermissions(room, permissions, remainingGasTo);
    }

    function onTag(uint64 serverID, uint64 roomID, uint64 messageID, address user) public view override onlyRoom(serverID, roomID) {
        emit Tagged(serverID, roomID, messageID, user);
    }

    function onMessageAccepted(
        uint64 serverID,
        uint64 roomID,
        uint64 messageID,
        uint messageHash,
        bool deployed
    ) public view override {
        address sender = deployed ? _messageAddress(serverID, roomID, messageID) : _roomAddress(serverID, roomID);
        require(msg.sender == sender, ErrorCodes.SENDER_IS_NOT_ROOM);
        emit MessageAccepted(messageHash, serverID, roomID, messageID, deployed);
    }


    function _createRoom(uint64 serverID, TvmCell params, Payment payment) internal {
        uint128 minValue = Gas.CREATE_ROOM_VALUE + payment.evers();
        require(msg.value >= minValue, ErrorCodes.TOO_LOW_MESSAGE_VALUE);

        emit CreateRoom(serverID);
        address server = _serverAddress(serverID);
        CallData data = _buildCallData(server, payment);
        if (payment.isEver()) {
            _createRoomPayEver(server, data, params);
        } else {
            TvmCell payload = abi.encode(data, params);
            _executePayTIP3(payment, server, payload, Gas.CREATE_ROOM_VALUE);
        }
    }

    function _buildCallData(address recipient, Payment payment) private view returns (CallData) {
        optional(TvmCell) userData = _userDatas.fetch(recipient);
        optional(Permissions) permissions = _permissions.fetch(recipient);
        return CallData(_owner, payment, userData, permissions);
    }

    function _sumTagsValue(Tag[] tags) private pure returns (uint128 sum) {
        for (Tag tag : tags) {
            sum += tag.value + Gas.TAG_VALUE;
        }
    }

    function _createRoomPayEver(address server, CallData data, TvmCell params) private pure {
        Server(server).createRoom{
            value: Gas.CREATE_ROOM_VALUE + data.payment.evers(),
            flag: MsgFlag.SENDER_PAYS_FEES,
            bounce: true
        }(data, params);
    }

    function _sendMessagePayEver(address room, CallData data, Tag[] tags, bool highlight, uint128 value) private view {
        Room(room).acceptMessage{
            value: value,
            flag: MsgFlag.SENDER_PAYS_FEES,
            bounce: true
        }(data, _currentMessageHash, tags, highlight);
    }

    function _executePayTIP3(Payment payment, address recipient, TvmCell payload, uint128 value) private {
        bool success = _transferTokens(payment.token, payment.amount, recipient, payload, value, MsgFlag.SENDER_PAYS_FEES);
        require(success, ErrorCodes.ZERO_VALUE_OR_TOKEN_NOT_EXISTS);
    }

    function _setPubkeys(uint[] pubkeys) private {
        for (uint pubkey : pubkeys) {
            _pubkeys[pubkey] = true;
        }
    }

    function _setPermissions(address entity, optional(Permissions) permissions, address remainingGasTo) private {
        bool removed = !permissions.hasValue();
        emit PermissionChanged(entity, removed);
        if (removed) {
            delete _permissions[entity];
        } else {
            _permissions[entity] = permissions.get();
        }
        IUser(remainingGasTo).onPermissionChanged{value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false}(entity, removed);
    }

    function _onAcceptTokensTransfer(address token, uint128 amount, address sender, TvmCell /*payload*/) internal override {
        _reserve();
        emit Deposited(token, amount);
        IUser(sender).onTokenDeposited{value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false}(token, amount);
    }

    // todo withdraw evers and tip3

}
